use std::collections::HashMap;
use std::path::{Path, PathBuf};

use async_trait::async_trait;
use lazy_static::lazy_static;
use tera::Tera;
use tracing::error;

use crate::error::BindgenResult;
use crate::{BuiltinPlugin, DojoData};

#[cfg(test)]
mod tests;

lazy_static! {
    pub static ref TEMPLATES: Tera = {
        match Tera::new("src/plugins/typescript_scaffold/templates/**/*.tpl.ts") {
            Ok(t) => t,
            Err(e) => {
                println!("Parsing error(s): {}", e);
                ::std::process::exit(1);
            }
        }
    };
}
/// TypescriptScaffoldPlugin is a plugin that generates typescript scaffold code.
/// Inherits typescript plugin as this only adds features to it
/// This plugin aims to scaffold mandatory ts files for a ts dojo client project
/// We want developpers to be able to easily scaffold a client project without having to clone one
/// of our examples.
/// Most of the files are pretty straightforward as they mainly are templates that we create on
/// behalf of the user.
pub struct TypescriptScaffoldPlugin {
    /// Templates engine
    templates: Tera,
}

impl TypescriptScaffoldPlugin {
    /// Creates a new TypescriptScaffoldPlugin
    pub fn new() -> Self {
        Self { templates: TEMPLATES.clone() }
    }

    /// Generates header for files. Different from parent plugin
    /// because in contrast to the parent plugin, developper can
    /// override files as they are not so tied with cairo code
    /// but dependent from it.
    fn header(&self) -> String {
        format!(
            "
// Generated by dojo-bindgen on {}.
// Feel free to update content of this file as this file can be regenerated.
// generate again with `sozo build --scaffold` 
",
            chrono::Utc::now().to_rfc2822()
        )
    }

    /// Simple function to render a template based on a path
    /// * `path` - path to the template
    /// * `ctx` - context to render the template
    fn handle_file(&self, path: &str, mut ctx: tera::Context) -> String {
        ctx.insert("header", &self.header().as_str());
        self.templates.render(path, &ctx).unwrap_or_else(|e| {
            error!(target: "sozo::cli::commands::build", error = %e, "Failed to render scaffold template.");
            String::new()
        })
    }

    /// Gather all data needed to generate setup.ts
    /// * `data` - dojo data
    fn handle_setup(&self, _data: &DojoData) -> String {
        let ctx = tera::Context::new();
        self.handle_file("setup.tpl.ts", ctx)
    }

    /// Gather all data needed to generate world.ts
    /// * `data` - dojo data
    fn handle_world(&self, _data: &DojoData) -> String {
        let ctx = tera::Context::new();
        self.handle_file("world.tpl.ts", ctx)
    }

    /// Gather all data needed to generate system.ts
    /// * `data` - dojo data
    fn handle_system(&self, data: &DojoData) -> String {
        let mut ctx = tera::Context::new();
        let systems = data
            .contracts
            .iter()
            .map(|(_, c)| {
                c.systems
                    .iter()
                    .map(|s| s.to_function().unwrap().name.to_string())
                    .collect::<Vec<String>>()
            })
            .collect::<Vec<Vec<String>>>();
        ctx.insert("systems", &systems);
        self.handle_file("system.tpl.ts", ctx)
    }

    /// Gather all data needed to generate clientModels.ts
    /// * `data` - dojo data
    fn handle_client_models(&self, _data: &DojoData) -> String {
        let ctx = tera::Context::new();
        self.handle_file("clientModels.tpl.ts", ctx)
    }

    /// Gather all data needed to generate clientComponents.ts
    /// * `data` - dojo data
    fn handle_client_components(&self, _data: &DojoData) -> String {
        let ctx = tera::Context::new();
        self.handle_file("clientComponents.tpl.ts", ctx)
    }
}

#[async_trait]
impl BuiltinPlugin for TypescriptScaffoldPlugin {
    async fn generate_code(&self, data: &DojoData) -> BindgenResult<HashMap<PathBuf, Vec<u8>>> {
        let mut out: HashMap<PathBuf, Vec<u8>> = HashMap::new();

        // Scaffold setup codegen
        let setup_path = Path::new("setup.ts").to_owned();
        let setup = self.handle_setup(data);
        out.insert(setup_path, setup.as_bytes().to_vec());

        // Scaffold world codegen
        let world_path = Path::new("world.ts").to_owned();
        let world = self.handle_world(data);
        out.insert(world_path, world.as_bytes().to_vec());

        // Scaffold systems codegen
        let system_path = Path::new("system.ts").to_owned();
        let system = self.handle_system(data);
        out.insert(system_path, system.as_bytes().to_vec());

        // Scaffold clientModels codegen
        let client_models_path = Path::new("clientModels.ts").to_owned();
        let client_models = self.handle_client_models(data);
        out.insert(client_models_path, client_models.as_bytes().to_vec());

        // Scaffold clientComponents codegen
        let client_components_path = Path::new("clientComponents.ts").to_owned();
        let client_components = self.handle_client_components(data);
        out.insert(client_components_path, client_components.as_bytes().to_vec());

        Ok(out)
    }
}
